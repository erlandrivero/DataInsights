    
    # ============================================================================
    # Section 2: AI Classification Analysis & Recommendations
    # ============================================================================
    st.divider()
    st.subheader("ü§ñ 2. AI Classification Analysis & Recommendations")
    
    # Generate AI Analysis Button - Only show if not already done
    if 'ml_classification_ai_analysis' not in st.session_state:
        if st.button("üîç Generate AI Classification Analysis", type="primary", use_container_width=True, key="ml_class_ai_btn"):
            # Immediate feedback
            processing_placeholder = st.empty()
            processing_placeholder.info("‚è≥ **Processing...** Please wait, do not click again.")
            
            with st.status("ü§ñ Analyzing dataset for ML Classification...", expanded=True) as status:
                try:
                    processing_placeholder.empty()
                    
                    import time
                    from utils.ai_smart_detection import get_ai_recommendation
                    
                    status.write("Analyzing data structure and quality...")
                    time.sleep(0.5)
                    
                    status.write("Evaluating classification suitability...")
                    time.sleep(0.5)
                    
                    status.write("Generating AI recommendations...")
                    status.write(f"Analyzing {len(df)} rows, {len(df.columns)} columns: {list(df.columns)}")
                    
                    ai_analysis = get_ai_recommendation(df, task_type='classification')
                    st.session_state.ml_classification_ai_analysis = ai_analysis
                    
                    status.update(label="‚úÖ AI analysis complete!", state="complete")
                    st.rerun()
                except Exception as e:
                    status.update(label="‚ùå Analysis failed", state="error")
                    st.error(f"Error generating AI analysis: {str(e)}")
    else:
        # AI Analysis exists - show results
        ai_recs = st.session_state.ml_classification_ai_analysis
        
        # Performance Risk Assessment
        performance_risk = ai_recs.get('performance_risk', 'Low')
        risk_emoji = {'Low': 'üü¢', 'Medium': 'üü°', 'High': 'üî¥'}.get(performance_risk, '‚ùì')
        
        col1, col2 = st.columns([2, 1])
        with col1:
            st.info(f"**‚ö° Performance Risk:** {risk_emoji} {performance_risk} - Dataset suitability for Streamlit Cloud")
        with col2:
            if st.button("üîÑ Regenerate Analysis", use_container_width=True, key="ml_regen_btn"):
                del st.session_state.ml_classification_ai_analysis
                st.rerun()
        
        # Data Suitability Assessment - AI DECISION POINT
        data_suitability = ai_recs.get('data_suitability', 'Unknown')
        suitability_emoji = {'Excellent': 'üåü', 'Good': '‚úÖ', 'Fair': '‚ö†Ô∏è', 'Poor': '‚ùå'}.get(data_suitability, '‚ùì')
        
        # AI-DRIVEN BLOCKING LOGIC
        if data_suitability == 'Poor':
            st.error(f"**üìä AI Assessment:** {suitability_emoji} {data_suitability} for ML Classification")
            
            # Show AI reasoning for why it's not suitable
            suitability_reasoning = ai_recs.get('suitability_reasoning', 'AI determined this data is not suitable for ML Classification')
            st.error(f"**ü§ñ AI Recommendation:** {suitability_reasoning}")
            
            # Show AI suggestions
            ai_suggestions = ai_recs.get('alternative_suggestions', [])
            if ai_suggestions:
                st.info("**üí° AI Suggestions:**")
                for suggestion in ai_suggestions:
                    st.write(f"- {suggestion}")
            else:
                st.info("**üí° AI Suggestions:**")
                st.write("- Use Sample Iris Dataset (perfect for classification)")
                st.write("- Ensure target column has 2+ classes with sufficient samples")
                st.write("- Remove or group rare classes")
            
            st.warning("**‚ö†Ô∏è Module not available for this dataset based on AI analysis.**")
            st.stop()  # AI-DRIVEN STOP - Only stop if AI says data is Poor
        else:
            # AI approves - show positive assessment
            st.success(f"**üìä AI Assessment:** {suitability_emoji} {data_suitability} for ML Classification")
            
            # Suitability reasoning
            suitability_reasoning = ai_recs.get('suitability_reasoning', 'AI determined this data is suitable for ML Classification')
            with st.expander("üí° Why this suitability rating?", expanded=False):
                st.info(suitability_reasoning)
        
        # Performance Warnings (only shown if AI approves)
        if performance_risk in ['Medium', 'High']:
            perf_warnings = ai_recs.get('performance_warnings', [])
            if perf_warnings:
                st.warning("‚ö†Ô∏è **Performance Warnings:**")
                for warning in perf_warnings:
                    st.write(f"‚Ä¢ {warning}")
        
        # Optimization Suggestions
        optimization_suggestions = ai_recs.get('optimization_suggestions', [])
        if optimization_suggestions:
            with st.expander("üöÄ AI Optimization Suggestions", expanded=True):
                for suggestion in optimization_suggestions:
                    st.write(f"‚Ä¢ {suggestion}")
        
        # Columns to Consider Excluding
        features_to_exclude = ai_recs.get('features_to_exclude', [])
        if features_to_exclude:
            with st.expander("üö´ Columns AI Recommends Excluding Before Training", expanded=False):
                for feature_info in features_to_exclude:
                    if isinstance(feature_info, dict):
                        st.write(f"‚Ä¢ **{feature_info['column']}**: {feature_info['reason']}")
                    else:
                        st.write(f"‚Ä¢ {feature_info}")
        
        # Recommended Models (if AI provides)
        recommended_models = ai_recs.get('recommended_models', [])
        if recommended_models:
            with st.expander("üéØ AI-Recommended Models for Your Data", expanded=False):
                st.info("Based on your dataset characteristics, AI recommends prioritizing these models:")
                for model_info in recommended_models:
                    if isinstance(model_info, dict):
                        st.write(f"‚Ä¢ **{model_info.get('model', 'Unknown')}**: {model_info.get('reason', 'Recommended')}")
                    else:
                        st.write(f"‚Ä¢ {model_info}")
    
    # Don't show configuration until AI analysis is complete
    if 'ml_classification_ai_analysis' not in st.session_state:
        st.info("ü§ñ **Generate AI Analysis above to determine if this dataset is suitable for ML Classification and get intelligent presets.**")
        return  # Stop here until AI analysis is done
    
    # Only proceed if AI approved the data
    ai_recs = st.session_state.get('ml_classification_ai_analysis', {})
    if ai_recs.get('data_suitability', 'Unknown') == 'Poor':
        return  # Already stopped above, but double-check
    
    # ============================================================================
    # Dataset Validation (Informational Only - AI makes final decision)
    # ============================================================================
    st.divider()
    st.subheader("üìä 3. Dataset Validation (Informational)")
    
    with st.expander("üîç Technical Validation Details", expanded=False):
        st.info("**Note:** AI analysis above provides the authoritative assessment. This section shows technical validation details for reference.")
        
        # Show basic data stats
        st.write(f"**Dataset:** {len(df):,} rows √ó {len(df.columns)} columns")
        numeric_cols = df.select_dtypes(include=['int64', 'float64']).columns.tolist()
        categorical_cols = df.select_dtypes(include=['object', 'category']).columns.tolist()
        st.write(f"**Features:** {len(numeric_cols)} numeric, {len(categorical_cols)} categorical")
        
        # Show any rule-based warnings (non-blocking)
        if len(df) < 50:
            st.warning(f"‚ö†Ô∏è **Rule-based check:** Dataset has {len(df)} rows (recommend 100+ for reliable models)")
        else:
            st.success(f"‚úÖ **Rule-based check passed:** Sufficient samples ({len(df):,} rows)")
